@startuml OAuthTokenStateDiagram
!theme plain
title 状態遷移図 - OAuth2認証状態管理（詳細設計対応版）

[*] --> Unauthenticated : アプリ起動

state Unauthenticated {
  Unauthenticated : entry / clearStoredToken()
  Unauthenticated : do / showLoginPrompt()
  Unauthenticated : do / checkSavedCredentials()
}

Unauthenticated --> Authenticating : startAuth() / initiateOAuth()
Unauthenticated --> Authenticated : [savedTokenValid] / loadCredentials()

state Authenticating {
  Authenticating : entry / generatePKCE()
  Authenticating : entry / generateState()
  Authenticating : do / openBrowser(authUrl)
  Authenticating : do / waitForCallback()
  
  state PKCEFlow {
    PKCEFlow : entry / buildAuthUrl(pkceChallenge)
    PKCEFlow : do / displayAuthURL()
    PKCEFlow : do / pollCallback()
  }
  
  state CodeExchange {
    CodeExchange : entry / validateState()
    CodeExchange : entry / sendTokenRequest(pkceVerifier)
    CodeExchange : do / validateTokenResponse()
  }
  
  PKCEFlow --> CodeExchange : callbackReceived(code, state)
}

Authenticating --> Authenticated : tokenReceived() / storeCredentials()
Authenticating --> AuthenticationFailed : authError() / setError()
Authenticating --> Unauthenticated : userCancelled() / cleanup()

state Authenticated {
  user_id: String
  expires_at: DateTime<Utc>
  
  Authenticated : entry / notifyAuthSuccess()
  Authenticated : entry / startExpiryMonitoring()
  Authenticated : do / enableAPIAccess()
  Authenticated : do / validateTokenPeriodically()
  
  state TokenValid {
    TokenValid : do / allowAPIRequests()
    TokenValid : do / monitorExpiry()
  }
  
  state TokenNearExpiry {
    TokenNearExpiry : entry / scheduleAutoRefresh()
    TokenNearExpiry : do / warnUserIfNeeded()
  }
  
  TokenValid --> TokenNearExpiry : expiryApproaching() [timeLeft < 5min]
}

Authenticated --> Refreshing : tokenExpiring() / startRefresh()
Authenticated --> TokenExpired : tokenExpired() / setExpired()
Authenticated --> Unauthenticated : logout() / clearAllTokens()
Authenticated --> AuthenticationFailed : tokenInvalid() / setAuthFailed()

state Refreshing {
  user_id: String
  refresh_started_at: DateTime<Utc>
  
  Refreshing : entry / validateRefreshToken()
  Refreshing : entry / sendRefreshRequest()
  Refreshing : do / monitorRefreshProgress()
  Refreshing : exit / updateStoredCredentials()
  
  state RefreshInProgress {
    RefreshInProgress : do / callTokenEndpoint()
    RefreshInProgress : do / handleRefreshResponse()
  }
  
  state RefreshValidation {
    RefreshValidation : do / validateNewAccessToken()
    RefreshValidation : do / updateTokenMetadata()
  }
  
  RefreshInProgress --> RefreshValidation : responseReceived()
}

Refreshing --> Authenticated : refreshSuccess() / setAuthenticated()
Refreshing --> TokenExpired : refreshFailed() / setExpired()
Refreshing --> AuthenticationFailed : refreshError() / setAuthFailed()

state TokenExpired {
  can_refresh: bool
  
  TokenExpired : entry / disableAPIAccess()
  TokenExpired : do / displayExpiryNotice()
  TokenExpired : do / checkRefreshTokenValidity()
  
  state RefreshAvailable {
    RefreshAvailable : do / showAutoRefreshOption()
  }
  
  state ReauthRequired {
    ReauthRequired : do / showReauthPrompt()
  }
  
  TokenExpired --> RefreshAvailable : [can_refresh=true]
  TokenExpired --> ReauthRequired : [can_refresh=false]
}

TokenExpired --> Refreshing : attemptRefresh() [can_refresh=true]
TokenExpired --> Authenticating : startReauth() / clearTokens()
TokenExpired --> Unauthenticated : giveUp() / reset()

state AuthenticationFailed {
  error: AuthError
  retry_possible: bool
  
  AuthenticationFailed : entry / logAuthFailure()
  AuthenticationFailed : entry / analyzeErrorType()
  AuthenticationFailed : do / displayErrorMessage()
  AuthenticationFailed : do / suggestRecoveryAction()
  
  state RecoverableError {
    RecoverableError : do / showRetryOption()
    RecoverableError : do / implementBackoffStrategy()
  }
  
  state NonRecoverableError {
    NonRecoverableError : do / showReauthOption()
    NonRecoverableError : do / clearInvalidCredentials()
  }
  
  AuthenticationFailed --> RecoverableError : [retry_possible=true]
  AuthenticationFailed --> NonRecoverableError : [retry_possible=false]
}

AuthenticationFailed --> Authenticating : retry() / clearError() [retry_possible=true]
AuthenticationFailed --> Unauthenticated : reset() / clearAll()

' 自動遷移・タイマー
Authenticated --> Refreshing : [timer:expiryTime-5min]
Refreshing --> TokenExpired : [timer:refreshTimeout(30s)]
TokenValid --> TokenNearExpiry : [timer:expiryTime-5min]

' 状態仕様
note right of Authenticating
  **PKCE認証フロー:**
  - code_verifier生成 (43-128文字)
  - code_challenge生成 (SHA256)
  - state生成 (CSRF対策)
  - 認証URL構築・ブラウザ起動
  
  **タイムアウト設定:**
  - 認証フロー: 10分
  - コールバック待機: 2分
  
  **セキュリティ:**
  - PKCE必須 (RFC 7636)
  - state検証必須
end note

note left of Authenticated
  **認証済み状態管理:**
  - user_id: ユーザー識別子
  - expires_at: トークン有効期限
  - 定期的な有効性検証 (1分間隔)
  - APIアクセス許可制御
  
  **自動更新判定:**
  - 期限5分前: 自動更新開始
  - 期限1分前: 緊急更新
  - 期限切れ: TokenExpired状態
end note

note bottom of Refreshing
  **リフレッシュ戦略:**
  - user_id: 継続認証ユーザー
  - refresh_started_at: 更新開始時刻
  - リフレッシュトークン検証
  - 新アクセストークン取得・保存
  
  **エラー処理・再試行:**
  - ネットワークエラー: 指数バックオフ(1s, 2s, 4s)
  - 無効リフレッシュトークン: TokenExpired遷移
  - レート制限: 遅延後リトライ
  - タイムアウト: 30秒
end note

note right of TokenExpired
  **期限切れ処理:**
  - can_refresh: リフレッシュ可能性
  - APIアクセス即座無効化
  - ユーザー通知表示
  
  **回復オプション:**
  - リフレッシュトークン有効: 自動更新
  - リフレッシュトークン無効: 再認証
  - ユーザー選択: 継続/ログアウト
end note

note left of AuthenticationFailed
  **認証失敗分析:**
  - error: 詳細エラー情報
  - retry_possible: 再試行可能性
  - エラー種別の自動判定
  
  **回復戦略:**
  - 回復可能: 自動再試行
  - 非回復: ユーザー介入要求
  - 永続的失敗: 完全リセット
end note

@enduml