@startuml IntegrationTestSequence
!theme plain
title 統合テストシーケンス図 - E2Eテストシナリオ

actor "Test Runner" as runner
participant "Test Harness" as harness
participant "Mock Zoom API" as mockapi
participant "Test App Instance" as app
participant "Mock File System" as mockfs
participant "Property Test Engine" as proptest
participant "Test Database" as testdb

== Test Setup Phase ==

runner -> harness : setup_integration_test()
activate harness

harness -> mockapi : start_mock_server(port: 8080)
activate mockapi
mockapi --> harness : MockServer(url)

harness -> mockfs : create_temp_directory()
activate mockfs
mockfs --> harness : TempDir(path)

harness -> testdb : initialize_test_data()
activate testdb
testdb -> testdb : load_test_recordings()
testdb -> testdb : load_test_users()
testdb --> harness : TestData(users, recordings)

harness -> app : new_with_config(test_config)
activate app
app -> app : initialize_test_mode()
app --> harness : AppInstance

== Authentication Test Scenario ==

harness -> runner : run_auth_test_scenario()

runner -> app : start_oauth_flow()
app -> mockapi : GET /oauth/authorize
mockapi --> app : authorization_page_html
app -> app : simulate_user_consent()
app -> mockapi : POST /oauth/token
mockapi -> mockapi : validate_pkce_challenge()
mockapi --> app : access_token + refresh_token

runner -> app : validate_authentication()
app -> app : check_token_storage()
app --> runner : AuthenticationSuccess

== Recording Retrieval Test Scenario ==

runner -> harness : run_recording_test_scenario()

harness -> proptest : generate_test_recordings(count: 100)
activate proptest
proptest -> proptest : generate_random_metadata()
proptest --> harness : Vec<TestRecording>
deactivate proptest

harness -> mockapi : setup_recording_endpoints(test_recordings)
mockapi -> mockapi : configure_pagination()
mockapi -> mockapi : configure_rate_limiting()

runner -> app : search_recordings(criteria)
app -> mockapi : GET /v2/users/me/recordings

loop Pagination Test
    mockapi --> app : recordings_page(page_token)
    app -> app : process_recordings_batch()
    app -> mockapi : GET /v2/users/me/recordings?next_page_token=XXX
end

app --> runner : SearchResults(recordings)

== Property-based Download Test (品質保証基盤戦略) ==

runner -> harness : run_property_download_test()

harness -> proptest : property_test_downloads()
activate proptest

proptest -> proptest : forall file_sizes in 1MB..4GB
proptest -> proptest : forall network_conditions in [fast, slow, unreliable]
proptest -> proptest : forall concurrent_downloads in 1..10

loop Property Test Iterations (1000x)
    proptest -> mockapi : setup_download_endpoint(file_size, network_condition)
    mockapi -> mockapi : configure_bandwidth_simulation()
    mockapi -> mockapi : configure_failure_injection()
    
    proptest -> app : download_files(test_urls, concurrent_limit)
    
    par Concurrent Downloads
        app -> mockapi : GET /download/file1
        mockapi -> mockapi : simulate_network_condition()
        mockapi --> app : file_chunk_stream
        
        app -> mockfs : write_chunk(data)
        mockfs --> app : bytes_written
    else
        app -> mockapi : GET /download/file2
        note right : 並列ダウンロード
    end
    
    proptest -> app : verify_download_invariants()
    app -> app : check_file_integrity()
    app -> app : check_progress_consistency()
    app -> app : check_error_handling()
    
    alt Property Violation Detected
        app --> proptest : PropertyViolation(details)
        proptest -> proptest : minimize_counterexample()
        proptest --> runner : TestFailure(minimal_case)
    else Property Satisfied
        app --> proptest : PropertySatisfied
    end
end

proptest --> harness : PropertyTestResults(passed: 995, failed: 5)
deactivate proptest

== Error Recovery Test Scenario ==

runner -> harness : run_error_recovery_test()

' ネットワーク断続テスト
harness -> mockapi : simulate_network_failure()
runner -> app : download_large_file()
app -> mockapi : GET /download/large_file
mockapi --> app : connection_reset

app -> app : detect_network_error()
app -> app : initiate_retry_with_backoff()

harness -> mockapi : restore_network_connection()
app -> mockapi : GET /download/large_file (Range: bytes=resumepoint-)
mockapi --> app : partial_content_stream

app -> app : resume_download()
app --> runner : DownloadCompleted(with_recovery)

== Test Cleanup Phase ==

runner -> harness : cleanup_integration_test()

harness -> app : shutdown()
app -> app : cleanup_temp_files()
app -> app : clear_test_data()
deactivate app

harness -> mockapi : stop_mock_server()
deactivate mockapi

harness -> mockfs : cleanup_temp_directory()
deactivate mockfs

harness -> testdb : cleanup_test_data()
deactivate testdb

harness --> runner : TestSuiteComplete(results)
deactivate harness

== Test Results Analysis ==

runner -> runner : analyze_test_results()
runner -> runner : generate_coverage_report()
runner -> runner : validate_performance_metrics()

note right of runner
  **品質保証基盤戦略としてのメトリクス:**
  - Property Test Coverage: 1000 cases (基盤要件)
  - Error Scenario Coverage: 15 types
  - Concurrency Test Coverage: 10 levels  
  - Integration Coverage: 95%+ code paths
  
  **基盤戦略位置づけ:**
  - 手動テスト困難領域の完全自動化
  - データ整合性・境界値・異常系の網羅検証
  - 品質保証の最重要基盤として実装
end note

@enduml