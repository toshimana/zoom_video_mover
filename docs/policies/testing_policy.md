# ãƒ†ã‚¹ãƒˆæ–¹é‡ - Zoom Video Mover

## ãƒ†ã‚¹ãƒˆã®åŸºæœ¬æ–¹é‡

### ãƒ†ã‚¹ãƒˆå“²å­¦ãƒ»åŸå‰‡
- **æ—©æœŸç™ºè¦‹**: é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã®æ—©ã„æ®µéšã§ã®ãƒã‚°ãƒ»å•é¡Œã®ç™ºè¦‹
- **è‡ªå‹•åŒ–å„ªå…ˆ**: æ‰‹å‹•ãƒ†ã‚¹ãƒˆã‚’æœ€å°é™ã«æŠ‘ãˆãŸè‡ªå‹•åŒ–ãƒ†ã‚¹ãƒˆä½“åˆ¶
- **åŒ…æ‹¬æ€§**: æ©Ÿèƒ½ãƒ»æ€§èƒ½ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»äº’æ›æ€§ã®å…¨é¢çš„ãªãƒ†ã‚¹ãƒˆ
- **å†ç¾æ€§**: ä¸€è²«ã—ãŸçµæœã‚’æä¾›ã™ã‚‹å®‰å®šã—ãŸãƒ†ã‚¹ãƒˆ
- **ç¶™ç¶šæ”¹å–„**: ãƒ†ã‚¹ãƒˆçµæœã«åŸºã¥ãç¶™ç¶šçš„ãªå“è³ªå‘ä¸Š
- **ãƒªã‚¹ã‚¯ãƒ™ãƒ¼ã‚¹**: é‡è¦åº¦ãƒ»ãƒªã‚¹ã‚¯ã«å¿œã˜ãŸãƒ†ã‚¹ãƒˆå„ªå…ˆåº¦è¨­å®š

### å“è³ªç›®æ¨™
- **æ©Ÿèƒ½å“è³ª**: å…¨è¦ä»¶ã®æ­£å¸¸å‹•ä½œä¿è¨¼ãƒ»å¢ƒç•Œå€¤ãƒ»ç•°å¸¸ç³»ã®é©åˆ‡ãªå‡¦ç†
- **æ€§èƒ½å“è³ª**: å¿œç­”æ™‚é–“ãƒ»ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆãƒ»ãƒªã‚½ãƒ¼ã‚¹åŠ¹ç‡ã®ç›®æ¨™é”æˆ
- **ä¿¡é ¼æ€§å“è³ª**: ã‚¨ãƒ©ãƒ¼å›å¾©ãƒ»é•·æ™‚é–“ç¨¼åƒãƒ»ã‚¹ãƒˆãƒ¬ã‚¹è€æ€§ã®ä¿è¨¼
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å“è³ª**: è„†å¼±æ€§ãƒ»ãƒ‡ãƒ¼ã‚¿ä¿è­·ãƒ»èªè¨¼ã®å®‰å…¨æ€§ç¢ºä¿
- **ä½¿ç”¨æ€§å“è³ª**: ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ãƒ»ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã®ç¢ºä¿

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ãƒ»åˆ†é¡

### ãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰æ§‹é€ 

```
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚   Manual Tests      â”‚ â† æœ€å°é™
           â”‚  (Exploratory)      â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚     E2E Tests             â”‚ â† å°‘æ•°ãƒ»é‡è¦ã‚·ãƒŠãƒªã‚ª
         â”‚  (Integration Tests)      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚        Unit Tests               â”‚ â† å¤§å¤šæ•°ãƒ»é«˜é€Ÿå®Ÿè¡Œ
       â”‚   (Property-based Tests)        â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ãƒ†ã‚¹ãƒˆåˆ†é¡ãƒ»è²¬ä»»ç¯„å›²

#### 1. Property-based Testingï¼ˆåŸºç›¤ãƒ†ã‚¹ãƒˆï¼‰
- **ç›®çš„**: ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ»ä¸å¤‰æ¡ä»¶ã®è‡ªå‹•æ¤œè¨¼
- **å¯¾è±¡**: ç´”ç²‹é–¢æ•°ãƒ»ãƒ‡ãƒ¼ã‚¿å¤‰æ›ãƒ»ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
- **å®Ÿè¡Œ**: 1000ã‚±ãƒ¼ã‚¹ä»¥ä¸Šã®è‡ªå‹•ç”Ÿæˆå…¥åŠ›ã§ã®æ¤œè¨¼
- **å„ªå…ˆåº¦**: æœ€é«˜ï¼ˆé–‹ç™ºã®åŸºç›¤ã¨ãªã‚‹ä¿¡é ¼æ€§ç¢ºä¿ï¼‰

#### 2. Unit Testingï¼ˆå˜ä½“ãƒ†ã‚¹ãƒˆï¼‰
- **ç›®çš„**: å€‹åˆ¥é–¢æ•°ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰ã®ä»•æ§˜ç¢ºèª
- **å¯¾è±¡**: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ãƒ»è¨ˆç®—å‡¦ç†ãƒ»çŠ¶æ…‹å¤‰æ›´
- **å®Ÿè¡Œ**: é–¢æ•°ãƒ¬ãƒ™ãƒ«ã®å…¥å‡ºåŠ›æ¤œè¨¼
- **å„ªå…ˆåº¦**: é«˜ï¼ˆæ©Ÿèƒ½ã®æ­£ç¢ºæ€§ä¿è¨¼ï¼‰

#### 3. Integration Testingï¼ˆçµ±åˆãƒ†ã‚¹ãƒˆï¼‰
- **ç›®çš„**: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–“é€£æºãƒ»å¤–éƒ¨ã‚·ã‚¹ãƒ†ãƒ æ¥ç¶š
- **å¯¾è±¡**: APIå‘¼ã³å‡ºã—ãƒ»ãƒ•ã‚¡ã‚¤ãƒ«I/Oãƒ»GUIæ“ä½œãƒ•ãƒ­ãƒ¼
- **å®Ÿè¡Œ**: å®Ÿéš›ã®ç’°å¢ƒã«è¿‘ã„æ¡ä»¶ã§ã®å‹•ä½œç¢ºèª
- **å„ªå…ˆåº¦**: é«˜ï¼ˆã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®å‹•ä½œä¿è¨¼ï¼‰

#### 4. Performance Testingï¼ˆæ€§èƒ½ãƒ†ã‚¹ãƒˆï¼‰
- **ç›®çš„**: å¿œç­”æ™‚é–“ãƒ»ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆãƒ»ãƒªã‚½ãƒ¼ã‚¹åŠ¹ç‡ã®æ¸¬å®š
- **å¯¾è±¡**: ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç†ãƒ»APIå‘¼ã³å‡ºã—ãƒ»ä¸¦è¡Œå‡¦ç†
- **å®Ÿè¡Œ**: è² è·æ¡ä»¶ä¸‹ã§ã®æ€§èƒ½æ¸¬å®š
- **å„ªå…ˆåº¦**: ä¸­ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã®å“è³ªä¿è¨¼ï¼‰

#### 5. Security Testingï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆï¼‰
- **ç›®çš„**: è„†å¼±æ€§ãƒ»ãƒ‡ãƒ¼ã‚¿ä¿è­·ãƒ»èªè¨¼ã®å®‰å…¨æ€§æ¤œè¨¼
- **å¯¾è±¡**: OAuthèªè¨¼ãƒ»è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ»é€šä¿¡æš—å·åŒ–
- **å®Ÿè¡Œ**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ãƒ»ä¾µå…¥ãƒ†ã‚¹ãƒˆ
- **å„ªå…ˆåº¦**: é«˜ï¼ˆãƒ‡ãƒ¼ã‚¿ä¿è­·ãƒ»ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ç¢ºä¿ï¼‰

#### 6. Compatibility Testingï¼ˆäº’æ›æ€§ãƒ†ã‚¹ãƒˆï¼‰
- **ç›®çš„**: æ§˜ã€…ãªç’°å¢ƒã§ã®å‹•ä½œç¢ºèª
- **å¯¾è±¡**: Windows ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒ»æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ»ç”»é¢è§£åƒåº¦
- **å®Ÿè¡Œ**: è¤‡æ•°ç’°å¢ƒã§ã®è‡ªå‹•ãƒ†ã‚¹ãƒˆ
- **å„ªå…ˆåº¦**: ä¸­ï¼ˆå¹…åºƒã„ãƒ¦ãƒ¼ã‚¶ãƒ¼å¯¾å¿œï¼‰

## Property-based Testingæˆ¦ç•¥

### ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£è¨­è¨ˆåŸå‰‡

#### 1. ä¸å¤‰æ¡ä»¶ï¼ˆInvariantsï¼‰
```rust
// è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®æ•´åˆæ€§ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
proptest! {
    /// è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ©ã‚¦ãƒ³ãƒ‰ãƒˆãƒªãƒƒãƒ—ç‰¹æ€§
    /// - ä¿å­˜â†’èª­ã¿è¾¼ã¿â†’ä¿å­˜ã®çµæœãŒä¸€è‡´ã™ã‚‹
    /// - ãƒ‡ãƒ¼ã‚¿ã®å®Œå…¨æ€§ãŒä¿ãŸã‚Œã‚‹
    #[test]
    fn config_roundtrip_property(
        client_id in "[a-zA-Z0-9]{10,50}",
        client_secret in "[a-zA-Z0-9]{20,100}",
        output_dir in prop::option::of("[a-zA-Z0-9/\\\\:.]{5,100}")
    ) {
        let original_config = Config {
            client_id: client_id.clone(),
            client_secret: client_secret.clone(),
            redirect_uri: Some("http://localhost:8080/callback".to_string()),
            output_directory: PathBuf::from(output_dir.unwrap_or_else(|| ".".to_string())),
        };
        
        // TOML ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
        let toml_string = toml::to_string(&original_config).unwrap();
        
        // ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
        let deserialized_config: Config = toml::from_str(&toml_string).unwrap();
        
        // ãƒ©ã‚¦ãƒ³ãƒ‰ãƒˆãƒªãƒƒãƒ—æ¤œè¨¼
        prop_assert_eq!(original_config.client_id, deserialized_config.client_id);
        prop_assert_eq!(original_config.client_secret, deserialized_config.client_secret);
        prop_assert_eq!(original_config.redirect_uri, deserialized_config.redirect_uri);
        prop_assert_eq!(original_config.output_directory, deserialized_config.output_directory);
        
        // å†ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã®ä¸€è‡´ç¢ºèª
        let re_serialized = toml::to_string(&deserialized_config).unwrap();
        prop_assert_eq!(toml_string, re_serialized);
    }
}
```

#### 2. é–¢æ•°ç‰¹æ€§ï¼ˆFunction Propertiesï¼‰
```rust
// ãƒ•ã‚¡ã‚¤ãƒ«åã‚µãƒ‹ã‚¿ã‚¤ã‚ºã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
proptest! {
    /// ãƒ•ã‚¡ã‚¤ãƒ«åã‚µãƒ‹ã‚¿ã‚¤ã‚ºã®ç‰¹æ€§
    /// - å‡ºåŠ›ã¯å¸¸ã«æœ‰åŠ¹ãªWindowsãƒ•ã‚¡ã‚¤ãƒ«å
    /// - é•·ã•åˆ¶é™å†…ã«åã¾ã‚‹
    /// - å±é™ºãªæ–‡å­—ãŒé™¤å»ã•ã‚Œã‚‹
    #[test]
    fn filename_sanitization_property(
        filename in ".*{1,500}" // ä»»æ„ã®æ–‡å­—åˆ—ï¼ˆæœ€å¤§500æ–‡å­—ï¼‰
    ) {
        prop_assume!(!filename.is_empty()); // ç©ºæ–‡å­—åˆ—ã¯é™¤å¤–
        
        let sanitized = sanitize_filename(&filename);
        
        // åŸºæœ¬ç‰¹æ€§
        prop_assert!(!sanitized.is_empty(), "sanitized filename must not be empty");
        prop_assert!(sanitized.len() <= 255, "must be within Windows limit");
        
        // ç„¡åŠ¹æ–‡å­—ã®é™¤å»ç¢ºèª
        let invalid_chars = ['<', '>', ':', '"', '|', '?', '*', '/', '\\'];
        for ch in invalid_chars {
            prop_assert!(!sanitized.contains(ch), "must not contain invalid char: {}", ch);
        }
        
        // åˆ¶å¾¡æ–‡å­—ã®é™¤å»ç¢ºèª
        prop_assert!(
            !sanitized.chars().any(|c| c.is_control()),
            "must not contain control characters"
        );
        
        // Windowsäºˆç´„èªã®å›é¿ç¢ºèª
        let reserved_names = ["CON", "PRN", "AUX", "NUL"];
        let name_upper = sanitized.to_uppercase();
        let base_name = name_upper.split('.').next().unwrap_or(&name_upper);
        
        if reserved_names.contains(&base_name) {
            prop_assert!(
                sanitized.starts_with('_'),
                "reserved name must be prefixed with underscore"
            );
        }
        
        // å†ªç­‰æ€§ç¢ºèªï¼ˆã‚µãƒ‹ã‚¿ã‚¤ã‚ºæ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«åã®å†ã‚µãƒ‹ã‚¿ã‚¤ã‚ºï¼‰
        prop_assert_eq!(sanitized, sanitize_filename(&sanitized));
    }
}
```

#### 3. é †åºé–¢ä¿‚ï¼ˆOrdering Propertiesï¼‰
```rust
// æ—¥ä»˜å‡¦ç†ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
proptest! {
    /// æ—¥ä»˜ç¯„å›²å‡¦ç†ã®ç‰¹æ€§
    /// - from_date <= to_date ã®é–¢ä¿‚ãŒä¿ãŸã‚Œã‚‹
    /// - æœ‰åŠ¹ãªæ—¥ä»˜ã®ã¿ãŒç”Ÿæˆã•ã‚Œã‚‹
    /// - æ—¥ä»˜è¨ˆç®—ã®æ­£ç¢ºæ€§
    #[test]
    fn date_range_property(
        year in 2020i32..2030i32,
        month1 in 1u32..13u32,
        month2 in 1u32..13u32,
        day_offset1 in 0u32..31u32,
        day_offset2 in 0u32..31u32
    ) {
        // æœ‰åŠ¹ãªæ—¥ä»˜ç”Ÿæˆ
        let date1 = generate_valid_date(year, month1, day_offset1);
        let date2 = generate_valid_date(year, month2, day_offset2);
        
        let (from_date, to_date) = if date1 <= date2 {
            (date1, date2)
        } else {
            (date2, date1)
        };
        
        // APIå‘¼ã³å‡ºã—å½¢å¼ã«å¤‰æ›
        let from_str = from_date.format("%Y-%m-%d").to_string();
        let to_str = to_date.format("%Y-%m-%d").to_string();
        
        // æ—¥ä»˜ç¯„å›²æ¤œè¨¼é–¢æ•°ã®ãƒ†ã‚¹ãƒˆ
        let result = validate_date_range(&from_str, &to_str);
        prop_assert!(result.is_ok(), "valid date range should pass validation");
        
        // é †åºé–¢ä¿‚ã®ä¿æŒç¢ºèª
        let parsed_from = NaiveDate::parse_from_str(&from_str, "%Y-%m-%d").unwrap();
        let parsed_to = NaiveDate::parse_from_str(&to_str, "%Y-%m-%d").unwrap();
        prop_assert!(parsed_from <= parsed_to, "from_date must be <= to_date");
        
        // æ—¥ä»˜ç¯„å›²è¨ˆç®—ã®æ¤œè¨¼
        let duration = parsed_to.signed_duration_since(parsed_from);
        prop_assert!(duration.num_days() >= 0, "duration must be non-negative");
        prop_assert!(duration.num_days() <= 365, "duration must be within reasonable range");
    }
}

/// æœˆã”ã¨ã®æœ‰åŠ¹æ—¥æ•°ã‚’è€ƒæ…®ã—ãŸæ—¥ä»˜ç”Ÿæˆ
fn generate_valid_date(year: i32, month: u32, day_offset: u32) -> NaiveDate {
    let max_day = match month {
        2 => {
            if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) {
                29 // ã†ã‚‹ã†å¹´
            } else {
                28 // å¹³å¹´
            }
        }
        4 | 6 | 9 | 11 => 30,
        _ => 31,
    };
    
    let day = (day_offset % max_day) + 1;
    NaiveDate::from_ymd_opt(year, month, day).unwrap()
}
```

#### 4. ã‚¨ãƒ©ãƒ¼å‡¦ç†ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
```rust
// ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
proptest! {
    /// ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®ç‰¹æ€§
    /// - ä¸æ­£å…¥åŠ›ã«å¯¾ã™ã‚‹é©åˆ‡ãªã‚¨ãƒ©ãƒ¼
    /// - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æœ‰ç”¨æ€§
    /// - ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã®ä¸€è²«æ€§ä¿æŒ
    #[test]
    fn error_handling_property(
        invalid_url in prop::option::of(".*"),
        invalid_path in prop::option::of(".*"),
        invalid_size in prop::option::of(any::<u64>())
    ) {
        // ä¸æ­£ãªãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ç”Ÿæˆ
        let request = DownloadRequest {
            file_id: FileId::new("test_file".to_string()).unwrap(),
            url: invalid_url.unwrap_or_else(|| "".to_string()),
            output_path: PathBuf::from(invalid_path.unwrap_or_else(|| "".to_string())),
            file_size: invalid_size.unwrap_or(0),
        };
        
        // ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®ãƒ†ã‚¹ãƒˆ
        let result = validate_download_request(&request);
        
        if request.url.is_empty() {
            // ç©ºURLã®å ´åˆã¯é©åˆ‡ãªã‚¨ãƒ©ãƒ¼ãŒè¿”ã•ã‚Œã‚‹
            prop_assert!(result.is_err(), "empty URL should cause error");
            
            let error = result.unwrap_err();
            prop_assert!(
                matches!(error, ZoomVideoMoverError::Validation { .. }),
                "should return validation error for empty URL"
            );
            
            // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æœ‰ç”¨æ€§ç¢ºèª
            let error_msg = error.to_string();
            prop_assert!(
                error_msg.to_lowercase().contains("url"),
                "error message should mention URL: {}",
                error_msg
            );
        }
        
        // ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã®ä¸€è²«æ€§ç¢ºèªï¼ˆã‚¨ãƒ©ãƒ¼å¾Œã‚‚æ­£å¸¸å‹•ä½œå¯èƒ½ï¼‰
        let valid_request = create_valid_download_request();
        let valid_result = validate_download_request(&valid_request);
        prop_assert!(
            valid_result.is_ok(),
            "system should remain functional after error"
        );
    }
}
```

### Property-based Testingå®Ÿè¡Œæˆ¦ç•¥

#### å®Ÿè¡Œè¨­å®š
```rust
// ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ†ã‚¹ãƒˆè¨­å®š
proptest! {
    #![proptest_config(ProptestConfig {
        cases: 1000,           // ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹æ•°
        max_shrink_iters: 1000, // æœ€å°åŒ–è©¦è¡Œå›æ•°
        timeout: 5000,         // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆãƒŸãƒªç§’ï¼‰
        max_global_rejects: 65536, // æœ€å¤§ãƒªã‚¸ã‚§ã‚¯ãƒˆæ•°
        source_file: Some("tests/property_tests.rs"), // ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«
        ..ProptestConfig::default()
    })]
    
    // ãƒ†ã‚¹ãƒˆé–¢æ•°
}

// ç’°å¢ƒå¤‰æ•°ã«ã‚ˆã‚‹å®Ÿè¡Œåˆ¶å¾¡
#[cfg(test)]
mod property_test_config {
    use super::*;
    
    pub fn get_test_cases() -> u32 {
        std::env::var("PROPTEST_CASES")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(1000)
    }
    
    pub fn is_verbose_mode() -> bool {
        std::env::var("PROPTEST_VERBOSE").is_ok()
    }
}
```

#### å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰
```bash
# åŸºæœ¬å®Ÿè¡Œ
cargo test --test property_tests

# è©³ç´°ãƒ­ã‚°ä»˜ãå®Ÿè¡Œ
PROPTEST_VERBOSE=1 cargo test --test property_tests -- --nocapture

# ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹æ•°æŒ‡å®š
PROPTEST_CASES=5000 cargo test --test property_tests

# ç‰¹å®šãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã¿å®Ÿè¡Œ
cargo test --test property_tests -- config_roundtrip_property

# ä¸¦åˆ—å®Ÿè¡Œåˆ¶å¾¡
cargo test --test property_tests -- --test-threads=4
```

## Unit Testingæˆ¦ç•¥

### å˜ä½“ãƒ†ã‚¹ãƒˆè¨­è¨ˆåŸå‰‡

#### 1. é–¢æ•°ãƒ¬ãƒ™ãƒ«ãƒ†ã‚¹ãƒˆ
```rust
#[cfg(test)]
mod unit_tests {
    use super::*;
    use tokio_test;
    
    /// OAuthèªè¨¼URLç”Ÿæˆã®ãƒ†ã‚¹ãƒˆ
    #[test]
    fn test_generate_auth_url() {
        let downloader = ZoomRecordingDownloader::new_with_test_config();
        let client_id = "test_client_id";
        
        let auth_url = downloader.generate_auth_url_sync(client_id).unwrap();
        
        // URLå½¢å¼ã®æ¤œè¨¼
        assert!(auth_url.starts_with("https://zoom.us/oauth/authorize"));
        assert!(auth_url.contains(&format!("client_id={}", client_id)));
        assert!(auth_url.contains("response_type=code"));
        assert!(auth_url.contains("scope="));
        
        // stateãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å­˜åœ¨ç¢ºèªï¼ˆCSRFå¯¾ç­–ï¼‰
        assert!(auth_url.contains("state="));
        
        // URLã®å¦¥å½“æ€§ç¢ºèª
        let parsed_url = url::Url::parse(&auth_url).unwrap();
        assert_eq!(parsed_url.scheme(), "https");
        assert_eq!(parsed_url.host_str(), Some("zoom.us"));
        assert_eq!(parsed_url.path(), "/oauth/authorize");
    }
    
    /// ãƒˆãƒ¼ã‚¯ãƒ³æœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆ
    #[test]
    fn test_token_validation() {
        let now = Utc::now();
        
        // æœ‰åŠ¹ãªãƒˆãƒ¼ã‚¯ãƒ³
        let valid_token = AuthToken {
            access_token: "valid_token".to_string(),
            token_type: "Bearer".to_string(),
            expires_at: now + chrono::Duration::hours(1),
            refresh_token: Some("refresh".to_string()),
            scope: "recording:read user:read".to_string(),
        };
        
        assert!(valid_token.is_valid());
        assert!(valid_token.has_scope("recording:read"));
        assert!(valid_token.has_all_scopes(&["recording:read", "user:read"]));
        
        // æœŸé™åˆ‡ã‚Œãƒˆãƒ¼ã‚¯ãƒ³
        let expired_token = AuthToken {
            access_token: "expired_token".to_string(),
            token_type: "Bearer".to_string(),
            expires_at: now - chrono::Duration::hours(1),
            refresh_token: None,
            scope: "recording:read".to_string(),
        };
        
        assert!(!expired_token.is_valid());
        
        // æ¨©é™ä¸è¶³ãƒˆãƒ¼ã‚¯ãƒ³
        let limited_token = AuthToken {
            access_token: "limited_token".to_string(),
            token_type: "Bearer".to_string(),
            expires_at: now + chrono::Duration::hours(1),
            refresh_token: None,
            scope: "user:read".to_string(),
        };
        
        assert!(!limited_token.has_scope("recording:read"));
        assert!(!limited_token.has_all_scopes(&["recording:read", "user:read"]));
    }
    
    /// ãƒ•ã‚¡ã‚¤ãƒ«åã‚µãƒ‹ã‚¿ã‚¤ã‚ºã®ãƒ†ã‚¹ãƒˆ
    #[test]
    fn test_filename_sanitization() {
        // åŸºæœ¬çš„ãªã‚µãƒ‹ã‚¿ã‚¤ã‚º
        assert_eq!(sanitize_filename("normal_file.txt"), "normal_file.txt");
        
        // ç„¡åŠ¹æ–‡å­—ã®ç½®æ›
        assert_eq!(sanitize_filename("file<>:\"|?*.txt"), "file___________.txt");
        
        // Windowsäºˆç´„èªã®å›é¿
        assert_eq!(sanitize_filename("CON.txt"), "_CON.txt");
        assert_eq!(sanitize_filename("con.txt"), "_con.txt");
        assert_eq!(sanitize_filename("PRN"), "_PRN");
        
        // é•·ã•åˆ¶é™
        let long_name = "a".repeat(300);
        let sanitized = sanitize_filename(&long_name);
        assert!(sanitized.len() <= 255);
        
        // æ—¥æœ¬èªãƒ•ã‚¡ã‚¤ãƒ«åã®ä¿æŒ
        assert_eq!(sanitize_filename("ä¼šè­°éŒ²ç”»_2024å¹´1æœˆ.mp4"), "ä¼šè­°éŒ²ç”»_2024å¹´1æœˆ.mp4");
        
        // åˆ¶å¾¡æ–‡å­—ã®é™¤å»
        let control_chars = "file\x00\x01\x1f.txt";
        let sanitized = sanitize_filename(control_chars);
        assert!(!sanitized.chars().any(|c| c.is_control()));
        assert_eq!(sanitized, "file.txt");
        
        // æœ«å°¾ã®ç©ºç™½ãƒ»ãƒ”ãƒªã‚ªãƒ‰é™¤å»
        assert_eq!(sanitize_filename("file. "), "file");
        assert_eq!(sanitize_filename("file..."), "file");
    }
}
```

#### 2. éåŒæœŸå‡¦ç†ãƒ†ã‚¹ãƒˆ
```rust
#[cfg(test)]
mod async_tests {
    use super::*;
    use tokio_test;
    use std::time::Duration;
    
    /// éåŒæœŸAPIå‘¼ã³å‡ºã—ã®ãƒ†ã‚¹ãƒˆ
    #[tokio::test]
    async fn test_api_call_with_timeout() {
        let mut mock_client = MockHttpClient::new();
        
        // æ­£å¸¸ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãƒ¢ãƒƒã‚¯
        mock_client.add_response(
            "https://api.zoom.us/v2/users/me/recordings",
            Ok(create_mock_recordings_response())
        );
        
        let downloader = ZoomRecordingDownloader::new_with_mock(mock_client);
        
        let result = downloader.get_recordings("2024-01-01", "2024-01-31").await;
        assert!(result.is_ok());
        
        let recordings = result.unwrap();
        assert!(!recordings.is_empty());
        assert_eq!(recordings[0].topic, "Test Meeting");
    }
    
    /// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†ã®ãƒ†ã‚¹ãƒˆ
    #[tokio::test]
    async fn test_api_timeout() {
        let mut mock_client = MockHttpClient::new();
        
        // é…å»¶ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãƒ¢ãƒƒã‚¯
        mock_client.add_delayed_response(
            "https://api.zoom.us/v2/users/me/recordings",
            Duration::from_secs(10), // 10ç§’é…å»¶
            Ok(create_mock_recordings_response())
        );
        
        let mut downloader = ZoomRecordingDownloader::new_with_mock(mock_client);
        downloader.set_timeout(Duration::from_secs(5)); // 5ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
        
        let result = downloader.get_recordings("2024-01-01", "2024-01-31").await;
        assert!(result.is_err());
        
        match result.unwrap_err() {
            ZoomVideoMoverError::Timeout { .. } => {}, // æœŸå¾…ã•ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼
            other => panic!("Expected timeout error, got: {:?}", other),
        }
    }
    
    /// ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã®ãƒ†ã‚¹ãƒˆ
    #[tokio::test]
    async fn test_parallel_downloads() {
        let mut mock_client = MockHttpClient::new();
        
        // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ¬ã‚¹ãƒãƒ³ã‚¹
        for i in 1..=5 {
            mock_client.add_response(
                &format!("https://example.com/file{}.mp4", i),
                Ok(MockResponse::with_body(vec![i as u8; 1024])) // 1KB ã®ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿
            );
        }
        
        let downloader = ZoomRecordingDownloader::new_with_mock(mock_client);
        
        // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªã‚¯ã‚¨ã‚¹ãƒˆä½œæˆ
        let requests: Vec<DownloadRequest> = (1..=5).map(|i| {
            DownloadRequest {
                file_id: FileId::new(format!("file{}", i)).unwrap(),
                url: format!("https://example.com/file{}.mp4", i),
                output_path: PathBuf::from(format!("./test_output/file{}.mp4", i)),
                file_size: 1024,
            }
        }).collect();
        
        let start_time = Instant::now();
        let results = downloader.download_files_parallel(requests).await;
        let elapsed = start_time.elapsed();
        
        // çµæœæ¤œè¨¼
        assert!(results.is_ok());
        let paths = results.unwrap();
        assert_eq!(paths.len(), 5);
        
        // ä¸¦åˆ—å‡¦ç†åŠ¹æœã®ç¢ºèªï¼ˆé€æ¬¡å®Ÿè¡Œã‚ˆã‚Šé«˜é€Ÿï¼‰
        assert!(elapsed < Duration::from_secs(5)); // ç†è«–çš„ã«ã¯1ç§’æœªæº€
        
        // ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª
        for path in paths {
            assert!(path.exists());
            assert_eq!(tokio::fs::metadata(&path).await.unwrap().len(), 1024);
        }
    }
}
```

#### 3. ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ
```rust
#[cfg(test)]
mod error_tests {
    use super::*;
    
    /// èªè¨¼ã‚¨ãƒ©ãƒ¼ã®ãƒ†ã‚¹ãƒˆ
    #[tokio::test]
    async fn test_authentication_errors() {
        let mut mock_client = MockHttpClient::new();
        
        // 401 Unauthorized ãƒ¬ã‚¹ãƒãƒ³ã‚¹
        mock_client.add_response(
            "https://zoom.us/oauth/token",
            Err(ZoomVideoMoverError::Http { 
                status: 401, 
                message: "Invalid client credentials".to_string() 
            })
        );
        
        let downloader = ZoomRecordingDownloader::new_with_mock(mock_client);
        
        let result = downloader.exchange_code("invalid_id", "invalid_secret", "auth_code").await;
        assert!(result.is_err());
        
        match result.unwrap_err() {
            ZoomVideoMoverError::Authentication { message } => {
                assert!(message.contains("Invalid client credentials"));
            }
            other => panic!("Expected authentication error, got: {:?}", other),
        }
    }
    
    /// ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã®ãƒ†ã‚¹ãƒˆ
    #[tokio::test]
    async fn test_network_errors() {
        let mut mock_client = MockHttpClient::new();
        
        // æ¥ç¶šã‚¨ãƒ©ãƒ¼ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        mock_client.add_response(
            "https://api.zoom.us/v2/users/me/recordings",
            Err(ZoomVideoMoverError::Network { 
                source: reqwest::Error::from(std::io::Error::new(
                    std::io::ErrorKind::ConnectionRefused,
                    "Connection refused"
                ))
            })
        );
        
        let downloader = ZoomRecordingDownloader::new_with_mock(mock_client);
        
        let result = downloader.get_recordings("2024-01-01", "2024-01-31").await;
        assert!(result.is_err());
        
        match result.unwrap_err() {
            ZoomVideoMoverError::Network { .. } => {}, // æœŸå¾…ã•ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼
            other => panic!("Expected network error, got: {:?}", other),
        }
    }
    
    /// ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ã®ãƒ†ã‚¹ãƒˆ
    #[tokio::test]
    async fn test_filesystem_errors() {
        let downloader = ZoomRecordingDownloader::new();
        
        // æ›¸ãè¾¼ã¿æ¨©é™ã®ãªã„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        let invalid_path = PathBuf::from("/root/cannot_write_here.txt");
        
        let request = DownloadRequest {
            file_id: FileId::new("test_file".to_string()).unwrap(),
            url: "https://example.com/file.mp4".to_string(),
            output_path: invalid_path,
            file_size: 1024,
        };
        
        let result = downloader.download_file(request).await;
        assert!(result.is_err());
        
        match result.unwrap_err() {
            ZoomVideoMoverError::FileSystem { operation, path, .. } => {
                assert_eq!(operation, "write");
                assert!(path.to_string_lossy().contains("cannot_write_here"));
            }
            other => panic!("Expected filesystem error, got: {:?}", other),
        }
    }
}
```

## Integration Testingæˆ¦ç•¥

### çµ±åˆãƒ†ã‚¹ãƒˆè¨­è¨ˆ

#### 1. APIçµ±åˆãƒ†ã‚¹ãƒˆ
```rust
// tests/integration_tests.rs
use zoom_video_mover::*;
use std::time::Duration;

#[tokio::test]
async fn test_oauth_integration() {
    // å®Ÿéš›ã®OAuthè¨­å®šï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
    let config = load_test_config().await;
    let downloader = ZoomRecordingDownloader::new_with_config(config);
    
    // èªè¨¼URLç”Ÿæˆ
    let auth_url = downloader.generate_auth_url().await.unwrap();
    assert!(auth_url.starts_with("https://zoom.us/oauth/authorize"));
    
    // ã“ã“ã§ã¯å®Ÿéš›ã®èªè¨¼ã¯è¡Œã‚ãšã€ãƒ¢ãƒƒã‚¯èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨
    let mock_auth_code = "test_auth_code";
    
    // ãƒ¢ãƒƒã‚¯ã‚µãƒ¼ãƒãƒ¼ã§ãƒˆãƒ¼ã‚¯ãƒ³äº¤æ›ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    let mock_server = setup_mock_oauth_server().await;
    
    let result = downloader.exchange_code(mock_auth_code).await;
    
    // ãƒ¢ãƒƒã‚¯ã‚µãƒ¼ãƒãƒ¼ãŒé©åˆ‡ãªãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¿”ã™ã“ã¨ã‚’ç¢ºèª
    assert!(result.is_ok());
    let token = result.unwrap();
    assert!(!token.access_token.is_empty());
    assert!(token.expires_at > chrono::Utc::now());
    
    teardown_mock_server(mock_server).await;
}

#[tokio::test]
async fn test_recording_retrieval_integration() {
    let downloader = setup_authenticated_downloader().await;
    
    // éŒ²ç”»ãƒªã‚¹ãƒˆå–å¾—
    let recordings = downloader.get_recordings("2024-01-01", "2024-01-31").await.unwrap();
    
    // åŸºæœ¬æ¤œè¨¼
    assert!(!recordings.is_empty());
    
    for recording in &recordings {
        // å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ç¢ºèª
        assert!(!recording.meeting_id.as_str().is_empty());
        assert!(!recording.topic.is_empty());
        assert!(!recording.recording_files.is_empty());
        
        // æ—¥ä»˜ã®å¦¥å½“æ€§ç¢ºèª
        assert!(recording.start_time.year() >= 2020);
        assert!(recording.duration > 0);
        
        // ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã®æ¤œè¨¼
        for file in &recording.recording_files {
            assert!(!file.id.as_str().is_empty());
            assert!(!file.download_url.is_empty());
            assert!(file.download_url.starts_with("https://"));
            assert!(file.file_size > 0);
        }
    }
}

#[tokio::test]
async fn test_end_to_end_download() {
    let downloader = setup_authenticated_downloader().await;
    let output_dir = setup_test_output_directory().await;
    
    // éŒ²ç”»æ¤œç´¢
    let recordings = downloader.get_recordings("2024-01-01", "2024-01-31").await.unwrap();
    assert!(!recordings.is_empty());
    
    // æœ€åˆã®éŒ²ç”»ã‹ã‚‰æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
    let recording = &recordings[0];
    let file = &recording.recording_files[0];
    
    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªã‚¯ã‚¨ã‚¹ãƒˆä½œæˆ
    let request = DownloadRequest {
        file_id: file.id.clone(),
        url: file.download_url.clone(),
        output_path: output_dir.join(format!("{}_{}.{}", 
            recording.topic.clone(),
            file.id.as_str(),
            file.file_type.to_lowercase()
        )),
        file_size: file.file_size,
    };
    
    // é€²æ—ç›£è¦–è¨­å®š
    let (progress_sender, mut progress_receiver) = tokio::sync::mpsc::channel(100);
    
    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Ÿè¡Œ
    let download_task = downloader.download_file(request.clone(), Some(progress_sender));
    let progress_monitor = tokio::spawn(async move {
        let mut last_progress = 0.0;
        while let Some(progress) = progress_receiver.recv().await {
            let progress_ratio = progress.bytes_downloaded as f64 / progress.bytes_total as f64;
            assert!(progress_ratio >= last_progress, "Progress should not decrease");
            assert!(progress_ratio <= 1.0, "Progress should not exceed 100%");
            last_progress = progress_ratio;
        }
    });
    
    let downloaded_path = download_task.await.unwrap();
    progress_monitor.await.unwrap();
    
    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰çµæœã®æ¤œè¨¼
    assert!(downloaded_path.exists());
    let file_metadata = tokio::fs::metadata(&downloaded_path).await.unwrap();
    assert_eq!(file_metadata.len(), file.file_size);
    
    // ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã®åŸºæœ¬æ¤œè¨¼ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã«å¿œã˜ã¦ï¼‰
    if request.output_path.extension().and_then(|s| s.to_str()) == Some("mp4") {
        // MP4ãƒ•ã‚¡ã‚¤ãƒ«ã®åŸºæœ¬ãƒ˜ãƒƒãƒ€ãƒ¼ãƒã‚§ãƒƒã‚¯
        let file_content = tokio::fs::read(&downloaded_path).await.unwrap();
        assert!(file_content.len() > 100, "MP4 file should have substantial content");
        // MP4ã®ftypãƒ˜ãƒƒãƒ€ãƒ¼ç¢ºèªï¼ˆç°¡æ˜“ãƒã‚§ãƒƒã‚¯ï¼‰
        assert!(file_content.windows(4).any(|w| w == b"ftyp"), "Should contain MP4 ftyp header");
    }
    
    cleanup_test_files(&output_dir).await;
}
```

#### 2. GUIçµ±åˆãƒ†ã‚¹ãƒˆ
```rust
// tests/gui_integration_tests.rs
use zoom_video_mover::gui::*;
use egui_testing::*;

#[tokio::test]
async fn test_gui_workflow() {
    let mut app = ZoomDownloaderApp::new_with_test_config();
    let mut egui_ctx = create_test_egui_context();
    
    // åˆæœŸçŠ¶æ…‹ã®ç¢ºèª
    assert_eq!(app.current_tab(), TabType::Config);
    assert!(!app.is_authenticated());
    
    // è¨­å®šå…¥åŠ›ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    app.set_config_input("test_client_id", "test_client_secret", "./test_output");
    
    // è¨­å®šä¿å­˜
    let save_result = app.save_configuration().await;
    assert!(save_result.is_ok());
    
    // èªè¨¼ã‚¿ãƒ–ã¸ã®é·ç§»
    app.set_current_tab(TabType::Authentication);
    
    // èªè¨¼URLç”Ÿæˆ
    let auth_url_result = app.generate_auth_url().await;
    assert!(auth_url_result.is_ok());
    
    // ãƒ¢ãƒƒã‚¯èªè¨¼ã‚³ãƒ¼ãƒ‰å…¥åŠ›
    app.set_auth_code("mock_auth_code");
    
    // ãƒˆãƒ¼ã‚¯ãƒ³äº¤æ›ï¼ˆãƒ¢ãƒƒã‚¯ã‚µãƒ¼ãƒãƒ¼ä½¿ç”¨ï¼‰
    let token_result = app.complete_authentication().await;
    assert!(token_result.is_ok());
    assert!(app.is_authenticated());
    
    // éŒ²ç”»ãƒªã‚¹ãƒˆã‚¿ãƒ–ã¸ã®è‡ªå‹•é·ç§»ç¢ºèª
    assert_eq!(app.current_tab(), TabType::Recordings);
    
    // éŒ²ç”»æ¤œç´¢
    app.set_date_range("2024-01-01", "2024-01-31");
    let search_result = app.search_recordings().await;
    assert!(search_result.is_ok());
    
    let recordings = app.get_recordings();
    assert!(!recordings.is_empty());
    
    // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ
    let first_recording = &recordings[0];
    app.select_recording_file(&first_recording.meeting_id, &first_recording.recording_files[0].id);
    
    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹
    let download_result = app.start_download().await;
    assert!(download_result.is_ok());
    
    // é€²æ—ã‚¿ãƒ–ã¸ã®è‡ªå‹•é·ç§»ç¢ºèª
    assert_eq!(app.current_tab(), TabType::Progress);
    assert!(app.is_downloading());
    
    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†ã¾ã§å¾…æ©Ÿï¼ˆãƒ¢ãƒƒã‚¯ç’°å¢ƒã§ã¯å³åº§ã«å®Œäº†ï¼‰
    app.wait_for_download_completion().await;
    assert!(!app.is_downloading());
}

#[test]
fn test_gui_component_rendering() {
    let mut app = ZoomDownloaderApp::new_with_test_config();
    let egui_ctx = create_test_egui_context();
    
    egui_ctx.run(Default::default(), |ctx| {
        egui::CentralPanel::default().show(ctx, |ui| {
            // è¨­å®šç”»é¢ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ
            app.render_config_panel(ui);
            
            // å¿…è¦ãªUIè¦ç´ ã®å­˜åœ¨ç¢ºèª
            assert!(ui.memory(|m| m.has_focus(egui::Id::new("client_id_input"))));
        });
    });
}
```

## Performance Testingæˆ¦ç•¥

### æ€§èƒ½ãƒ†ã‚¹ãƒˆè¨­è¨ˆ

#### 1. ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ
```rust
// benches/performance_benchmarks.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use zoom_video_mover::*;
use std::time::Duration;

fn benchmark_config_operations(c: &mut Criterion) {
    let mut group = c.benchmark_group("config_operations");
    
    // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿æ€§èƒ½
    group.bench_function("load_config", |b| {
        let config_path = "./test_data/benchmark_config.toml";
        setup_benchmark_config(config_path);
        
        b.iter(|| {
            let config = black_box(Config::load_from_file(config_path)).unwrap();
            black_box(config);
        });
    });
    
    // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜æ€§èƒ½
    group.bench_function("save_config", |b| {
        let config = create_benchmark_config();
        let config_path = "./test_data/benchmark_save_config.toml";
        
        b.iter(|| {
            black_box(config.save_to_file(config_path)).unwrap();
        });
    });
    
    group.finish();
}

fn benchmark_file_operations(c: &mut Criterion) {
    let mut group = c.benchmark_group("file_operations");
    
    // ãƒ•ã‚¡ã‚¤ãƒ«åã‚µãƒ‹ã‚¿ã‚¤ã‚ºæ€§èƒ½
    for input_size in [10, 100, 500].iter() {
        group.bench_with_input(
            BenchmarkId::new("sanitize_filename", input_size),
            input_size,
            |b, &size| {
                let filename = "a".repeat(size) + "<>:\"|?*" + &"b".repeat(size);
                b.iter(|| {
                    let sanitized = black_box(sanitize_filename(&filename));
                    black_box(sanitized);
                });
            },
        );
    }
    
    group.finish();
}

fn benchmark_download_operations(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let mut group = c.benchmark_group("download_operations");
    group.measurement_time(Duration::from_secs(30)); // é•·ã‚ã®æ¸¬å®šæ™‚é–“
    
    // ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ€§èƒ½
    for concurrent_count in [1, 3, 5, 10].iter() {
        group.bench_with_input(
            BenchmarkId::new("parallel_download", concurrent_count),
            concurrent_count,
            |b, &count| {
                let downloader = setup_benchmark_downloader_with_mocks(count);
                let requests = create_benchmark_download_requests(count);
                
                b.to_async(&rt).iter(|| async {
                    let results = black_box(
                        downloader.download_files_parallel(requests.clone()).await
                    ).unwrap();
                    black_box(results);
                });
            },
        );
    }
    
    group.finish();
}

criterion_group!(
    benches,
    benchmark_config_operations,
    benchmark_file_operations,
    benchmark_download_operations
);
criterion_main!(benches);
```

#### 2. è² è·ãƒ†ã‚¹ãƒˆ
```rust
// tests/load_tests.rs
use zoom_video_mover::*;
use std::sync::Arc;
use std::time::Duration;
use tokio::time::Instant;

#[tokio::test]
async fn test_concurrent_api_calls() {
    let downloader = Arc::new(setup_test_downloader_with_rate_limiting());
    let concurrent_requests = 20;
    let mut tasks = Vec::new();
    
    let start_time = Instant::now();
    
    // åŒæ™‚APIå‘¼ã³å‡ºã—
    for i in 0..concurrent_requests {
        let downloader_clone = downloader.clone();
        let task = tokio::spawn(async move {
            let from_date = format!("2024-{:02}-01", (i % 12) + 1);
            let to_date = format!("2024-{:02}-28", (i % 12) + 1);
            
            downloader_clone.get_recordings(&from_date, &to_date).await
        });
        tasks.push(task);
    }
    
    // å…¨ã‚¿ã‚¹ã‚¯ã®å®Œäº†ã‚’å¾…æ©Ÿ
    let results = futures::future::join_all(tasks).await;
    let elapsed = start_time.elapsed();
    
    // çµæœæ¤œè¨¼
    let mut success_count = 0;
    let mut rate_limit_count = 0;
    
    for result in results {
        match result.unwrap() {
            Ok(_) => success_count += 1,
            Err(ZoomVideoMoverError::RateLimit { .. }) => rate_limit_count += 1,
            Err(other) => panic!("Unexpected error: {:?}", other),
        }
    }
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¤œè¨¼
    assert!(success_count > 0, "At least some requests should succeed");
    assert!(elapsed < Duration::from_secs(60), "Should complete within reasonable time");
    
    // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã®é©åˆ‡ãªå‡¦ç†ç¢ºèª
    if rate_limit_count > 0 {
        println!("Rate limited requests: {}/{}", rate_limit_count, concurrent_requests);
    }
}

#[tokio::test]
async fn test_memory_usage_under_load() {
    let initial_memory = get_current_memory_usage();
    let downloader = setup_test_downloader();
    
    // å¤§é‡ã®å°ã•ãªãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    let mut download_tasks = Vec::new();
    for i in 0..100 {
        let request = create_small_file_download_request(i);
        let task = downloader.download_file(request);
        download_tasks.push(task);
    }
    
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–
    let memory_monitor = tokio::spawn(async {
        let mut max_memory = 0;
        for _ in 0..30 { // 30ç§’é–“ç›£è¦–
            let current_memory = get_current_memory_usage();
            max_memory = max_memory.max(current_memory);
            tokio::time::sleep(Duration::from_secs(1)).await;
        }
        max_memory
    });
    
    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Ÿè¡Œ
    let download_results = futures::future::try_join_all(download_tasks).await;
    let max_memory = memory_monitor.await.unwrap();
    
    // çµæœæ¤œè¨¼
    assert!(download_results.is_ok());
    
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡æ¤œè¨¼ï¼ˆ1GBä»¥å†…ï¼‰
    let memory_increase = max_memory - initial_memory;
    assert!(memory_increase < 1024 * 1024 * 1024, 
            "Memory usage should stay within limit: {} bytes", memory_increase);
    
    println!("Peak memory usage: {} MB", memory_increase / 1024 / 1024);
}

#[tokio::test]
async fn test_long_running_stability() {
    let downloader = setup_test_downloader();
    let start_time = Instant::now();
    let test_duration = Duration::from_secs(300); // 5åˆ†é–“
    
    let mut operation_count = 0;
    let mut error_count = 0;
    
    while start_time.elapsed() < test_duration {
        // æ§˜ã€…ãªæ“ä½œã‚’é †æ¬¡å®Ÿè¡Œ
        let operations = vec![
            test_config_load_save(),
            test_auth_url_generation(),
            test_recording_list_fetch(),
        ];
        
        for operation in operations {
            match operation.await {
                Ok(_) => operation_count += 1,
                Err(_) => error_count += 1,
            }
        }
        
        // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œå‡º
        if operation_count % 100 == 0 {
            let current_memory = get_current_memory_usage();
            println!("Operations: {}, Memory: {} MB", 
                    operation_count, current_memory / 1024 / 1024);
        }
        
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
    
    // å®‰å®šæ€§æ¤œè¨¼
    let error_rate = error_count as f64 / operation_count as f64;
    assert!(error_rate < 0.05, "Error rate should be under 5%: {:.2}%", error_rate * 100.0);
    
    println!("Stability test completed: {} operations, {:.2}% error rate", 
             operation_count, error_rate * 100.0);
}
```

## Security Testingæˆ¦ç•¥

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆè¨­è¨ˆ

#### 1. èªè¨¼ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
```rust
// tests/security_tests.rs
use zoom_video_mover::*;
use std::time::Duration;

#[tokio::test]
async fn test_oauth_security() {
    let downloader = ZoomRecordingDownloader::new();
    
    // CSRFæ”»æ’ƒå¯¾ç­–ãƒ†ã‚¹ãƒˆ
    let auth_url1 = downloader.generate_auth_url().await.unwrap();
    let auth_url2 = downloader.generate_auth_url().await.unwrap();
    
    // ç•°ãªã‚‹stateãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
    let state1 = extract_state_parameter(&auth_url1);
    let state2 = extract_state_parameter(&auth_url2);
    assert_ne!(state1, state2, "State parameters should be unique");
    assert!(state1.len() >= 16, "State parameter should be sufficiently long");
    
    // ä¸æ­£ãªstateãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã®èªè¨¼è©¦è¡Œ
    let invalid_auth_code = "invalid_code_with_wrong_state";
    let result = downloader.exchange_code(invalid_auth_code).await;
    assert!(result.is_err(), "Should reject invalid state parameter");
}

#[tokio::test]
async fn test_config_file_security() {
    let config = SecureConfig::new(
        "test_client_id".to_string(),
        "test_client_secret".to_string(),
        Some("http://localhost:8080/callback".to_string())
    );
    
    let temp_config_path = "./test_data/secure_config_test.toml";
    
    // æš—å·åŒ–ä¿å­˜
    let storage = EncryptedConfigStorage::new(PathBuf::from(temp_config_path)).unwrap();
    storage.save_config(&config).await.unwrap();
    
    // ãƒ•ã‚¡ã‚¤ãƒ«æ¨©é™ç¢ºèª
    let metadata = tokio::fs::metadata(temp_config_path).await.unwrap();
    let permissions = metadata.permissions();
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mode = permissions.mode();
        assert_eq!(mode & 0o777, 0o600, "Config file should be readable/writable by owner only");
    }
    
    // ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã®æš—å·åŒ–ç¢ºèª
    let raw_content = tokio::fs::read(temp_config_path).await.unwrap();
    let content_str = String::from_utf8_lossy(&raw_content);
    
    // å¹³æ–‡ã®æ©Ÿå¯†æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
    assert!(!content_str.contains("test_client_secret"), 
            "Config file should not contain plaintext secrets");
    assert!(!content_str.contains("client_id"), 
            "Config file should not contain plaintext field names");
    
    // æ­£å¸¸ãªå¾©å·åŒ–ç¢ºèª
    let loaded_config = storage.load_config().await.unwrap();
    assert_eq!(loaded_config.client_id, config.client_id);
    assert_eq!(loaded_config.client_secret(), config.client_secret());
    
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    tokio::fs::remove_file(temp_config_path).await.ok();
}

#[tokio::test]
async fn test_https_enforcement() {
    let downloader = ZoomRecordingDownloader::new();
    
    // HTTP URLã§ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰è©¦è¡Œï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é•åï¼‰
    let insecure_request = DownloadRequest {
        file_id: FileId::new("test".to_string()).unwrap(),
        url: "http://insecure.example.com/file.mp4".to_string(), // HTTP
        output_path: PathBuf::from("./test_output/insecure.mp4"),
        file_size: 1024,
    };
    
    let result = downloader.download_file(insecure_request).await;
    assert!(result.is_err(), "Should reject HTTP URLs");
    
    match result.unwrap_err() {
        ZoomVideoMoverError::Security { .. } => {}, // æœŸå¾…ã•ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼
        other => panic!("Expected security error, got: {:?}", other),
    }
    
    // HTTPS URLã¯æ­£å¸¸å‡¦ç†ï¼ˆãƒ¢ãƒƒã‚¯ç’°å¢ƒï¼‰
    let secure_request = DownloadRequest {
        file_id: FileId::new("test".to_string()).unwrap(),
        url: "https://secure.example.com/file.mp4".to_string(), // HTTPS
        output_path: PathBuf::from("./test_output/secure.mp4"),
        file_size: 1024,
    };
    
    let mock_downloader = setup_mock_downloader_for_https_test();
    let result = mock_downloader.download_file(secure_request).await;
    assert!(result.is_ok(), "HTTPS URLs should be accepted");
}

#[test]
fn test_input_validation() {
    // SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰
    let malicious_inputs = vec![
        "'; DROP TABLE users; --",
        "<script>alert('xss')</script>",
        "../../etc/passwd",
        "\x00\x01\x02", // NULL ãƒã‚¤ãƒˆæ”»æ’ƒ
        "A".repeat(10000), // ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼è©¦è¡Œ
    ];
    
    for malicious_input in malicious_inputs {
        // ãƒ•ã‚¡ã‚¤ãƒ«åã‚µãƒ‹ã‚¿ã‚¤ã‚ºã®å®‰å…¨æ€§ç¢ºèª
        let sanitized = sanitize_filename(malicious_input);
        assert!(!sanitized.contains('<'), "Should remove dangerous characters");
        assert!(!sanitized.contains('>'), "Should remove dangerous characters");
        assert!(!sanitized.contains('\x00'), "Should remove null bytes");
        assert!(sanitized.len() <= 255, "Should enforce length limits");
        
        // è¨­å®šå€¤ã®æ¤œè¨¼
        let config_result = Config::new()
            .client_id(malicious_input.to_string())
            .build();
        
        if malicious_input.is_empty() || malicious_input.contains('\x00') {
            assert!(config_result.is_err(), "Should reject invalid input");
        }
    }
}
```

#### 2. ãƒ‡ãƒ¼ã‚¿ä¿è­·ãƒ†ã‚¹ãƒˆ
```rust
#[test]
fn test_memory_security() {
    use std::ptr;
    
    // æ©Ÿå¯†æƒ…å ±ã®è‡ªå‹•ã‚¯ãƒªã‚¢ç¢ºèª
    let secret = SecretString::new("sensitive_data".to_string());
    let secret_ptr = secret.expose_secret().as_ptr();
    
    // ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã¦è‡ªå‹•ã‚¯ãƒªã‚¢ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
    {
        let temp_secret = secret.clone();
        assert_eq!(temp_secret.expose_secret(), "sensitive_data");
    } // ã“ã“ã§ temp_secret ãŒ Drop ã•ã‚Œã‚‹
    
    drop(secret); // æ˜ç¤ºçš„ã«Drop
    
    // ãƒ¡ãƒ¢ãƒªãŒå®Ÿéš›ã«ã‚¯ãƒªã‚¢ã•ã‚ŒãŸã‹ã®æ¤œè¨¼ã¯å›°é›£ã ãŒã€
    // zeroize ã‚¯ãƒ¬ãƒ¼ãƒˆã®å‹•ä½œã«ä¾å­˜
}

#[tokio::test]
async fn test_log_security() {
    // ãƒ­ã‚°å‡ºåŠ›ã‹ã‚‰æ©Ÿå¯†æƒ…å ±ã®æ¼æ´©ã‚’é˜²ããƒ†ã‚¹ãƒˆ
    let config = SecureConfig::new(
        "test_client_id".to_string(),
        "secret_client_secret".to_string(),
        None
    );
    
    let downloader = ZoomRecordingDownloader::new_with_secure_config(config);
    
    // èªè¨¼å‡¦ç†ã§ã®ãƒ­ã‚°ç¢ºèª
    let _result = downloader.authenticate().await;
    
    // ãƒ­ã‚°å‡ºåŠ›ã‚’ç¢ºèªï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯å°‚ç”¨ã®ãƒ­ã‚°ã‚­ãƒ£ãƒ—ãƒãƒ£ãŒå¿…è¦ï¼‰
    let log_content = capture_log_output().await;
    
    // æ©Ÿå¯†æƒ…å ±ãŒãƒ­ã‚°ã«å«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
    assert!(!log_content.contains("secret_client_secret"), 
            "Logs should not contain client secret");
    assert!(!log_content.contains("access_token"), 
            "Logs should not contain access tokens");
    
    // ãƒã‚¹ã‚¯ã•ã‚ŒãŸæƒ…å ±ãŒå«ã¾ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
    assert!(log_content.contains("***"), 
            "Logs should contain masked sensitive data");
}
```

## Test Automationæˆ¦ç•¥

### CI/CD ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³çµ±åˆ

#### 1. GitHub Actionsè¨­å®š
```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  test:
    name: Test Suite
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        rust: [stable, beta]
        
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: ${{ matrix.rust }}
        profile: minimal
        override: true
        components: rustfmt, clippy
    
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target/
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Check formatting
      run: cargo fmt --all -- --check
    
    - name: Lint with clippy
      run: cargo clippy --all-targets --all-features -- -D warnings
    
    - name: Run unit tests
      run: cargo test --lib
    
    - name: Run property-based tests
      run: cargo test --test property_tests
      env:
        PROPTEST_CASES: 1000
    
    - name: Run integration tests
      run: cargo test --test integration_tests
    
    - name: Run security tests
      run: cargo test --test security_tests
    
    - name: Generate test coverage
      run: |
        cargo install cargo-tarpaulin
        cargo tarpaulin --out Xml
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./cobertura.xml
        fail_ci_if_error: true

  performance:
    name: Performance Tests
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        profile: minimal
        override: true
    
    - name: Run benchmarks
      run: cargo bench
    
    - name: Store benchmark results
      uses: benchmark-action/github-action-benchmark@v1
      with:
        tool: 'cargo'
        output-file-path: target/criterion/benchmark.json
        github-token: ${{ secrets.GITHUB_TOKEN }}
        auto-push: true

  security:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Security audit
      run: |
        cargo install cargo-audit
        cargo audit
    
    - name: Dependency check
      run: |
        cargo install cargo-outdated
        cargo outdated
```

#### 2. ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¹ã‚¯ãƒªãƒ—ãƒˆ
```bash
#!/bin/bash
# scripts/run_tests.sh

set -e

echo "ğŸ§ª Running Zoom Video Mover Test Suite"

# åŸºæœ¬çš„ãªå“è³ªãƒã‚§ãƒƒã‚¯
echo "ğŸ“‹ Code formatting check..."
cargo fmt --all -- --check

echo "ğŸ“‹ Linting with clippy..."
cargo clippy --all-targets --all-features -- -D warnings

echo "ğŸ” Type checking..."
cargo check --all-targets

# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
echo "ğŸ§ª Unit tests..."
cargo test --lib

echo "ğŸ§ª Property-based tests..."
PROPTEST_CASES=1000 cargo test --test property_tests -- --nocapture

echo "ğŸ§ª Integration tests..."
cargo test --test integration_tests

echo "ğŸ”’ Security tests..."
cargo test --test security_tests

echo "âš¡ Performance tests..."
cargo test --test performance_tests --release

# ã‚«ãƒãƒ¬ãƒƒã‚¸ç”Ÿæˆ
echo "ğŸ“Š Generating test coverage..."
cargo tarpaulin --out Html

# ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Ÿè¡Œ
echo "ğŸƒ Running benchmarks..."
cargo bench

echo "âœ… All tests completed successfully!"
```

### ãƒ†ã‚¹ãƒˆå“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹

#### 1. ã‚«ãƒãƒ¬ãƒƒã‚¸æ¸¬å®š
```toml
# Cargo.toml - tarpaulinè¨­å®š
[package.metadata.tarpaulin]
exclude_files = [
    "src/main.rs",
    "tests/*",
    "benches/*",
]
ignore_panics = true
run_types = ["Tests", "Doctests"]
timeout = 300
```

#### 2. å“è³ªã‚²ãƒ¼ãƒˆå®šç¾©
```rust
// tests/quality_gates.rs
#[test]
fn test_coverage_requirements() {
    let coverage_report = load_coverage_report();
    
    // æœ€ä½ã‚«ãƒãƒ¬ãƒƒã‚¸è¦æ±‚
    assert!(coverage_report.line_coverage >= 0.90, 
            "Line coverage must be at least 90%: {:.1}%", 
            coverage_report.line_coverage * 100.0);
    
    assert!(coverage_report.branch_coverage >= 0.85,
            "Branch coverage must be at least 85%: {:.1}%",
            coverage_report.branch_coverage * 100.0);
    
    // é‡è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é«˜ã‚«ãƒãƒ¬ãƒƒã‚¸è¦æ±‚
    let oauth_coverage = coverage_report.module_coverage.get("oauth").unwrap();
    assert!(oauth_coverage >= &0.95,
            "OAuth module coverage must be at least 95%: {:.1}%",
            oauth_coverage * 100.0);
}

#[test]
fn test_performance_requirements() {
    let benchmark_results = load_benchmark_results();
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦æ±‚
    assert!(benchmark_results.config_load_time < Duration::from_millis(100),
            "Config loading should complete within 100ms");
    
    assert!(benchmark_results.auth_url_generation_time < Duration::from_millis(50),
            "Auth URL generation should complete within 50ms");
    
    assert!(benchmark_results.parallel_download_efficiency > 0.8,
            "Parallel download efficiency should be above 80%");
}
```

## çµè«–

æœ¬ãƒ†ã‚¹ãƒˆæ–¹é‡ã¯ã€**åŒ…æ‹¬çš„ãƒ»è‡ªå‹•åŒ–ãƒ»ç¶™ç¶šçš„**ãªå“è³ªä¿è¨¼ã‚’å®Ÿç¾ã™ã‚‹ç¾ä»£çš„ãªãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã‚’æä¾›ã—ã¾ã™ã€‚

### ãƒ†ã‚¹ãƒˆæ–¹é‡ã®ç‰¹å¾´
- **Property-based Testingä¸­å¿ƒ**: ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®è‡ªå‹•æ¤œè¨¼ã«ã‚ˆã‚‹é«˜ä¿¡é ¼æ€§
- **å¤šå±¤ãƒ†ã‚¹ãƒˆæ§‹é€ **: Unitãƒ»Integrationãƒ»Performanceãƒ»Securityã®å…¨é¢çš„ã‚«ãƒãƒ¼
- **è‡ªå‹•åŒ–å„ªå…ˆ**: CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³çµ±åˆã«ã‚ˆã‚‹ç¶™ç¶šçš„å“è³ªä¿è¨¼
- **ãƒªã‚¹ã‚¯ãƒ™ãƒ¼ã‚¹**: é‡è¦åº¦ã«å¿œã˜ãŸé©åˆ‡ãªãƒ†ã‚¹ãƒˆå„ªå…ˆåº¦è¨­å®š
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é‡è¦–**: èªè¨¼ãƒ»æš—å·åŒ–ãƒ»å…¥åŠ›æ¤œè¨¼ã®åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆ
- **æ€§èƒ½ä¿è¨¼**: ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ»è² è·ãƒ†ã‚¹ãƒˆã«ã‚ˆã‚‹æ€§èƒ½å“è³ªç¢ºä¿

### æœŸå¾…åŠ¹æœ
- **å“è³ªå‘ä¸Š**: å¤šè§’çš„ãªãƒ†ã‚¹ãƒˆã«ã‚ˆã‚‹é«˜å“è³ªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢å®Ÿç¾
- **é–‹ç™ºåŠ¹ç‡**: è‡ªå‹•åŒ–ã«ã‚ˆã‚‹ãƒ†ã‚¹ãƒˆå·¥æ•°å‰Šæ¸›ãƒ»æ—©æœŸå•é¡Œç™ºè¦‹
- **ä¿¡é ¼æ€§ç¢ºä¿**: Property-basedãƒ†ã‚¹ãƒˆã«ã‚ˆã‚‹äºˆæœŸã—ãªã„ãƒã‚°ã®é˜²æ­¢
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–**: åŒ…æ‹¬çš„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆã«ã‚ˆã‚‹è„†å¼±æ€§æ’é™¤
- **æ€§èƒ½ä¿è¨¼**: ç¶™ç¶šçš„ãªæ€§èƒ½ç›£è¦–ã«ã‚ˆã‚‹æœ€é©ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“
- **ä¿å®ˆæ€§å‘ä¸Š**: å›å¸°ãƒ†ã‚¹ãƒˆã«ã‚ˆã‚‹å®‰å…¨ãªæ©Ÿèƒ½è¿½åŠ ãƒ»ä¿®æ­£

ã“ã®åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆæ–¹é‡ã«ã‚ˆã‚Šã€**ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœŸå¾…ã‚’è¶…ãˆã‚‹é«˜å“è³ªãƒ»é«˜æ€§èƒ½ãƒ»é«˜ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿç¾ã—ã¾ã™ã€‚